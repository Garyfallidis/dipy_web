{"parents": [{"link": "../../documentation/", "title": "Documentation"}, {"link": "../", "title": "API Reference"}], "prev": null, "next": {"link": "../dipy.direction/", "title": "<code class=\"docutils literal notranslate\"><span class=\"pre\">direction</span></code>"}, "title": "<code class=\"docutils literal notranslate\"><span class=\"pre\">denoise</span></code>", "meta": {}, "body": "<div class=\"section\" id=\"module-dipy.denoise\">\n<span id=\"denoise\"></span><h1><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<table border=\"1\" class=\"longtable docutils\">\n<colgroup>\n<col width=\"10%\" />\n<col width=\"90%\" />\n</colgroup>\n<tbody valign=\"top\">\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.bench\" title=\"dipy.denoise.bench\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench</span></code></a></td>\n<td>Run benchmarks for module using nose.</td>\n</tr>\n<tr class=\"row-even\"><td><a class=\"reference internal\" href=\"#dipy.denoise.test\" title=\"dipy.denoise.test\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">test</span></code></a></td>\n<td>Run tests for module using nose.</td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"module-dipy.denoise.adaptive_soft_matching\">\n<span id=\"module-denoise-adaptive-soft-matching\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.adaptive_soft_matching</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.adaptive_soft_matching\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table border=\"1\" class=\"longtable docutils\">\n<colgroup>\n<col width=\"10%\" />\n<col width=\"90%\" />\n</colgroup>\n<tbody valign=\"top\">\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\" title=\"dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adaptive_soft_matching</span></code></a>(ima,&nbsp;fimau,&nbsp;fimao,&nbsp;sigma)</td>\n<td>Adaptive Soft Coefficient Matching</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.localpca\">\n<span id=\"module-denoise-localpca\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.localpca</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.localpca\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table border=\"1\" class=\"longtable docutils\">\n<colgroup>\n<col width=\"10%\" />\n<col width=\"90%\" />\n</colgroup>\n<tbody valign=\"top\">\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.localpca.eigh\" title=\"dipy.denoise.localpca.eigh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigh</span></code></a>(a[,&nbsp;b,&nbsp;lower,&nbsp;eigvals_only,&nbsp;\u2026])</td>\n<td>Solve an ordinary or generalized eigenvalue problem for a complex Hermitian or real symmetric matrix.</td>\n</tr>\n<tr class=\"row-even\"><td><a class=\"reference internal\" href=\"#dipy.denoise.localpca.localpca\" title=\"dipy.denoise.localpca.localpca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">localpca</span></code></a>(arr,&nbsp;sigma[,&nbsp;mask,&nbsp;pca_method,&nbsp;\u2026])</td>\n<td>Local PCA-based denoising of diffusion datasets.</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.nlmeans\">\n<span id=\"module-denoise-nlmeans\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.nlmeans</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.nlmeans\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table border=\"1\" class=\"longtable docutils\">\n<colgroup>\n<col width=\"10%\" />\n<col width=\"90%\" />\n</colgroup>\n<tbody valign=\"top\">\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.nlmeans.nlmeans\" title=\"dipy.denoise.nlmeans.nlmeans\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans</span></code></a>(arr,&nbsp;sigma[,&nbsp;mask,&nbsp;patch_radius,&nbsp;\u2026])</td>\n<td>Non-local means for denoising 3D and 4D images</td>\n</tr>\n<tr class=\"row-even\"><td><a class=\"reference internal\" href=\"#dipy.denoise.nlmeans.nlmeans_3d\" title=\"dipy.denoise.nlmeans.nlmeans_3d\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans_3d</span></code></a></td>\n<td>Non-local means for denoising 3D images</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.noise_estimate\">\n<span id=\"module-denoise-noise-estimate\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.noise_estimate</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.noise_estimate\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table border=\"1\" class=\"longtable docutils\">\n<colgroup>\n<col width=\"10%\" />\n<col width=\"90%\" />\n</colgroup>\n<tbody valign=\"top\">\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.convolve\" title=\"dipy.denoise.noise_estimate.convolve\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">convolve</span></code></a>(input,&nbsp;weights[,&nbsp;output,&nbsp;mode,&nbsp;\u2026])</td>\n<td>Multidimensional convolution.</td>\n</tr>\n<tr class=\"row-even\"><td><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\" title=\"dipy.denoise.noise_estimate.estimate_sigma\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">estimate_sigma</span></code></a>(arr[,&nbsp;\u2026])</td>\n<td>Standard deviation estimation from local patches</td>\n</tr>\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"dipy.denoise.noise_estimate.piesno\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">piesno</span></code></a>(data,&nbsp;N[,&nbsp;alpha,&nbsp;l,&nbsp;itermax,&nbsp;eps,&nbsp;\u2026])</td>\n<td>Probabilistic Identification and Estimation of Noise (PIESNO).</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.non_local_means\">\n<span id=\"module-denoise-non-local-means\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.non_local_means</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.non_local_means\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table border=\"1\" class=\"longtable docutils\">\n<colgroup>\n<col width=\"10%\" />\n<col width=\"90%\" />\n</colgroup>\n<tbody valign=\"top\">\n<tr class=\"row-odd\"><td><a class=\"reference internal\" href=\"#dipy.denoise.non_local_means.nlmeans_block\" title=\"dipy.denoise.non_local_means.nlmeans_block\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans_block</span></code></a></td>\n<td>Non-Local Means Denoising Using Blockwise Averaging</td>\n</tr>\n<tr class=\"row-even\"><td><a class=\"reference internal\" href=\"#dipy.denoise.non_local_means.non_local_means\" title=\"dipy.denoise.non_local_means.non_local_means\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">non_local_means</span></code></a>(arr,&nbsp;sigma[,&nbsp;mask,&nbsp;\u2026])</td>\n<td>Non-local means for denoising 3D and 4D images, using</td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"bench\">\n<h3>bench<a class=\"headerlink\" href=\"#bench\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.bench\">\n<code class=\"descclassname\">dipy.denoise.</code><code class=\"descname\">bench</code><span class=\"sig-paren\">(</span><em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.bench\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Run benchmarks for module using nose.</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>label</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional</span></dt>\n<dd><p class=\"first\">Identifies the benchmarks to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:\n* \u2018fast\u2019 - the default - which corresponds to the <code class=\"docutils literal notranslate\"><span class=\"pre\">nosetests</span> <span class=\"pre\">-A</span></code></p>\n<blockquote>\n<div><p>option of \u2018not slow\u2019.</p>\n</div></blockquote>\n<ul class=\"simple\">\n<li>\u2018full\u2019 - fast (as above) and slow benchmarks as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.</li>\n<li>None or \u2018\u2019 - run all tests.</li>\n</ul>\n<p class=\"last\">attribute_identifier - string passed directly to nosetests as \u2018-A\u2019.</p>\n</dd>\n<dt><strong>verbose</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd><p class=\"first last\">Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</p>\n</dd>\n<dt><strong>extra_argv</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list, optional</span></dt>\n<dd><p class=\"first last\">List with any extra arguments to pass to nosetests.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>success</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd><p class=\"first last\">Returns True if running the benchmarks works, False if an error\noccurred.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">Notes</p>\n<p>Benchmarks are like tests, but have names starting with \u201cbench\u201d instead\nof \u201ctest\u201d, and can be found under the \u201cbenchmarks\u201d sub-directory of the\nmodule.</p>\n<p>Each NumPy module exposes <cite>bench</cite> in its namespace to run all benchmarks\nfor it.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">success</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span> \n<span class=\"go\">Running benchmarks for numpy.lib</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">using 562341 items:</span>\n<span class=\"go\">unique:</span>\n<span class=\"go\">0.11</span>\n<span class=\"go\">unique1d:</span>\n<span class=\"go\">0.11</span>\n<span class=\"go\">ratio: 1.0</span>\n<span class=\"go\">nUnique: 56230 == 56230</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">OK</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">success</span> \n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"test\">\n<h3>test<a class=\"headerlink\" href=\"#test\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.test\">\n<code class=\"descclassname\">dipy.denoise.</code><code class=\"descname\">test</code><span class=\"sig-paren\">(</span><em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em>, <em>doctests=False</em>, <em>coverage=False</em>, <em>raise_warnings=None</em>, <em>timer=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.test\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Run tests for module using nose.</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>label</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional</span></dt>\n<dd><p class=\"first\">Identifies the tests to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:\n* \u2018fast\u2019 - the default - which corresponds to the <code class=\"docutils literal notranslate\"><span class=\"pre\">nosetests</span> <span class=\"pre\">-A</span></code></p>\n<blockquote>\n<div><p>option of \u2018not slow\u2019.</p>\n</div></blockquote>\n<ul class=\"simple\">\n<li>\u2018full\u2019 - fast (as above) and slow tests as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.</li>\n<li>None or \u2018\u2019 - run all tests.</li>\n</ul>\n<p class=\"last\">attribute_identifier - string passed directly to nosetests as \u2018-A\u2019.</p>\n</dd>\n<dt><strong>verbose</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd><p class=\"first last\">Verbosity value for test outputs, in the range 1-10. Default is 1.</p>\n</dd>\n<dt><strong>extra_argv</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list, optional</span></dt>\n<dd><p class=\"first last\">List with any extra arguments to pass to nosetests.</p>\n</dd>\n<dt><strong>doctests</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">If True, run doctests in module. Default is False.</p>\n</dd>\n<dt><strong>coverage</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first\">If True, report coverage of NumPy code. Default is False.\n(This requires the <a href=\"#id1\"><span class=\"problematic\" id=\"id2\">`</span></a>coverage module:</p>\n<blockquote class=\"last\">\n<div><p>&lt;<a class=\"reference external\" href=\"http://nedbatchelder.com/code/modules/coverage.html\">http://nedbatchelder.com/code/modules/coverage.html</a>&gt;`_).</p>\n</div></blockquote>\n</dd>\n<dt><strong>raise_warnings</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None, str or sequence of warnings, optional</span></dt>\n<dd><p class=\"first\">This specifies which warnings to configure as \u2018raise\u2019 instead\nof being shown once during the test execution.  Valid strings are:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>\u201cdevelop\u201d : equals <code class=\"docutils literal notranslate\"><span class=\"pre\">(Warning,)</span></code></li>\n<li>\u201crelease\u201d : equals <code class=\"docutils literal notranslate\"><span class=\"pre\">()</span></code>, don\u2019t raise on any warnings.</li>\n</ul>\n</div></blockquote>\n<p class=\"last\">The default is to use the class initialization value.</p>\n</dd>\n<dt><strong>timer</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool or int, optional</span></dt>\n<dd><p class=\"first last\">Timing of individual tests with <code class=\"docutils literal notranslate\"><span class=\"pre\">nose-timer</span></code> (which needs to be\ninstalled).  If True, time tests and report on all of them.\nIf an integer (say <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code>), report timing results for <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> slowest\ntests.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>result</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">object</span></dt>\n<dd><p class=\"first last\">Returns the result of running the tests as a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">nose.result.TextTestResult</span></code> object.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">Notes</p>\n<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.\nFor example, to run all tests for numpy.lib:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span> \n</pre></div>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span> \n<span class=\"go\">Running unit tests for numpy.lib</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">Ran 976 tests in 3.933s</span>\n</pre></div>\n</div>\n<p>OK</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">errors</span> \n<span class=\"go\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">knownfail</span> \n<span class=\"go\">[]</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"adaptive-soft-matching\">\n<h3>adaptive_soft_matching<a class=\"headerlink\" href=\"#adaptive-soft-matching\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\">\n<code class=\"descclassname\">dipy.denoise.adaptive_soft_matching.</code><code class=\"descname\">adaptive_soft_matching</code><span class=\"sig-paren\">(</span><em>ima</em>, <em>fimau</em>, <em>fimao</em>, <em>sigma</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Adaptive Soft Coefficient Matching</p>\n<p>Combines two filtered 3D-images at different resolutions and the orginal\nimage. Returns the resulting combined image.</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>ima</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">the original (not filtered) image</span></dt>\n<dd></dd>\n<dt><strong>fimau</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D double array,</span></dt>\n<dd><p class=\"first last\">filtered image with optimized non-local means using a small block\n(suggested:3x3), which corresponds to a \u201chigh resolution\u201d filter.</p>\n</dd>\n<dt><strong>fimao</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D double array,</span></dt>\n<dd><p class=\"first last\">filtered image with optimized non-local means using a small block\n(suggested:5x5), which corresponds to a \u201clow resolution\u201d filter.</p>\n</dd>\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">the estimated standard deviation of the Gaussian random variables</span></dt>\n<dd><p class=\"first last\">that explain the rician noise. Note: In P. Coupe et al. the\nrician noise was simulated as sqrt((f+x)^2 + (y)^2) where f is\nthe pixel value and x and y are independent realizations of a\nrandom variable with Normal distribution, with mean=0 and\nstandard deviation=h</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>fima</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D double array</span></dt>\n<dd><p class=\"first last\">output denoised array which is of the same shape as that of\nthe input</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">References</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"refa1efa84d4b-coupe11\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id3\">[Coupe11]</a></td><td>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\n\u201cMultiresolution Non-Local Means Filter for 3D MR Image\nDenoising\u201d IET Image Processing, Institution of Engineering\nand Technology,\n2011</td></tr>\n</tbody>\n</table>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"eigh\">\n<h3>eigh<a class=\"headerlink\" href=\"#eigh\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.localpca.eigh\">\n<code class=\"descclassname\">dipy.denoise.localpca.</code><code class=\"descname\">eigh</code><span class=\"sig-paren\">(</span><em>a</em>, <em>b=None</em>, <em>lower=True</em>, <em>eigvals_only=False</em>, <em>overwrite_a=False</em>, <em>overwrite_b=False</em>, <em>turbo=True</em>, <em>eigvals=None</em>, <em>type=1</em>, <em>check_finite=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.eigh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Solve an ordinary or generalized eigenvalue problem for a complex\nHermitian or real symmetric matrix.</p>\n<p>Find eigenvalues w and optionally eigenvectors v of matrix <cite>a</cite>, where\n<cite>b</cite> is positive definite:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>              <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"p\">[:,</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"n\">b</span> <span class=\"n\">v</span><span class=\"p\">[:,</span><span class=\"n\">i</span><span class=\"p\">]</span>\n<span class=\"n\">v</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,:]</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span> <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"p\">[:,</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n<span class=\"n\">v</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,:]</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span> <span class=\"n\">b</span> <span class=\"n\">v</span><span class=\"p\">[:,</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n</pre></div>\n</div>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>a</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">(M, M) array_like</span></dt>\n<dd><p class=\"first last\">A complex Hermitian or real symmetric matrix whose eigenvalues and\neigenvectors will be computed.</p>\n</dd>\n<dt><strong>b</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">(M, M) array_like, optional</span></dt>\n<dd><p class=\"first last\">A complex Hermitian or real symmetric definite positive matrix in.\nIf omitted, identity matrix is assumed.</p>\n</dd>\n<dt><strong>lower</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">Whether the pertinent array data is taken from the lower or upper\ntriangle of <cite>a</cite>. (Default: lower)</p>\n</dd>\n<dt><strong>eigvals_only</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">Whether to calculate only eigenvalues and no eigenvectors.\n(Default: both are calculated)</p>\n</dd>\n<dt><strong>turbo</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">Use divide and conquer algorithm (faster but expensive in memory,\nonly for generalized eigenvalue problem and if eigvals=None)</p>\n</dd>\n<dt><strong>eigvals</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple (lo, hi), optional</span></dt>\n<dd><p class=\"first last\">Indexes of the smallest and largest (in ascending order) eigenvalues\nand corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.\nIf omitted, all eigenvalues and eigenvectors are returned.</p>\n</dd>\n<dt><strong>type</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd><p class=\"first\">Specifies the problem type to be solved:</p>\n<blockquote class=\"last\">\n<div><p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>\n<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>\n<p>type = 3: b a v[:,i] = w[i]   v[:,i]</p>\n</div></blockquote>\n</dd>\n<dt><strong>overwrite_a</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">Whether to overwrite data in <cite>a</cite> (may improve performance)</p>\n</dd>\n<dt><strong>overwrite_b</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">Whether to overwrite data in <cite>b</cite> (may improve performance)</p>\n</dd>\n<dt><strong>check_finite</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd><p class=\"first last\">Whether to check that the input matrices contain only finite numbers.\nDisabling may give a performance gain, but may result in problems\n(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>w</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">(N,) float ndarray</span></dt>\n<dd><p class=\"first last\">The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each\nrepeated according to its multiplicity.</p>\n</dd>\n<dt><strong>v</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">(M, N) complex ndarray</span></dt>\n<dd><p class=\"first\">(if eigvals_only == False)</p>\n<p>The normalized selected eigenvector corresponding to the\neigenvalue w[i] is the column v[:,i].</p>\n<p>Normalization:</p>\n<blockquote class=\"last\">\n<div><p>type 1 and 3: v.conj() a      v  = w</p>\n<p>type 2: inv(v).conj() a  inv(v) = w</p>\n<p>type = 1 or 2: v.conj() b      v  = I</p>\n<p>type = 3: v.conj() inv(b) v  = I</p>\n</div></blockquote>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-odd field\"><th class=\"field-name\">Raises:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>LinAlgError</strong></dt>\n<dd><p class=\"first last\">If eigenvalue computation does not converge,\nan error occurred, or b matrix is not definite positive. Note that\nif input matrices are not symmetric or hermitian, no error is reported\nbut results will be wrong.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<div class=\"admonition seealso\">\n<p class=\"first admonition-title\">See also</p>\n<dl class=\"last docutils\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigvalsh</span></code></dt>\n<dd>eigenvalues of symmetric or Hermitian arrays</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eig</span></code></dt>\n<dd>eigenvalues and right eigenvectors for non-symmetric arrays</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.denoise.localpca.eigh\" title=\"dipy.denoise.localpca.eigh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigh</span></code></a></dt>\n<dd>eigenvalues and right eigenvectors for symmetric/Hermitian arrays</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigh_tridiagonal</span></code></dt>\n<dd>eigenvalues and right eiegenvectors for symmetric/Hermitian tridiagonal matrices</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>This function does not check the input array for being hermitian/symmetric\nin order to allow for representing arrays with only their upper/lower\ntriangular parts.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.linalg</span> <span class=\"k\">import</span> <span class=\"n\">eigh</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">eigh</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">A</span> <span class=\"o\">@</span> <span class=\"n\">v</span> <span class=\"o\">-</span> <span class=\"n\">v</span> <span class=\"o\">@</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)))</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"localpca\">\n<h3>localpca<a class=\"headerlink\" href=\"#localpca\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.localpca.localpca\">\n<code class=\"descclassname\">dipy.denoise.localpca.</code><code class=\"descname\">localpca</code><span class=\"sig-paren\">(</span><em>arr</em>, <em>sigma</em>, <em>mask=None</em>, <em>pca_method='eig'</em>, <em>patch_radius=2</em>, <em>tau_factor=2.3</em>, <em>out_dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.localpca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Local PCA-based denoising of diffusion datasets.</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">4D array</span></dt>\n<dd><p class=\"first last\">Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions.</p>\n</dd>\n<dt><strong>mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D boolean array</span></dt>\n<dd><p class=\"first last\">A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or 3D array</span></dt>\n<dd><p class=\"first last\">Standard deviation of the noise estimated from the data.</p>\n</dd>\n<dt><strong>pca_method</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019</span></dt>\n<dd><p class=\"first last\">Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt><strong>patch_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd><p class=\"first last\">The radius of the local patch to be taken around each voxel (in\nvoxels). Default: 2 (denoise in blocks of 5x5x5 voxels).</p>\n</dd>\n<dt><strong>tau_factor</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd><p class=\"first\">Thresholding of PCA eigenvalues is done by nulling out eigenvalues that\nare smaller than:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\tau = (\\tau_{factor} \\sigma)^2\\]</div>\n<p class=\"last\">Default: 2.3, based on the results described in <a class=\"reference internal\" href=\"#rc1f8d7038c98-manjon13\" id=\"id4\">[Manjon13]</a>.</p>\n</dd>\n<dt><strong>out_dtype</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or dtype, optional</span></dt>\n<dd><p class=\"first last\">The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>denoised_arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">4D array</span></dt>\n<dd><p class=\"first last\">This is the denoised array of the same size as that of the input data,\nclipped to non-negative values</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">References</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"rc1f8d7038c98-manjon13\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[Manjon13]</td><td><em>(<a class=\"fn-backref\" href=\"#id4\">1</a>, <a class=\"fn-backref\" href=\"#id5\">2</a>)</em> Manjon JV, Coupe P, Concha L, Buades A, Collins DL (2013)\nDiffusion Weighted Image Denoising Using Overcomplete Local\nPCA. PLoS ONE 8(9): e73021.\n<a class=\"reference external\" href=\"https://doi.org/10.1371/journal.pone.0073021\">https://doi.org/10.1371/journal.pone.0073021</a></td></tr>\n</tbody>\n</table>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlmeans\">\n<h3>nlmeans<a class=\"headerlink\" href=\"#nlmeans\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.nlmeans.nlmeans\">\n<code class=\"descclassname\">dipy.denoise.nlmeans.</code><code class=\"descname\">nlmeans</code><span class=\"sig-paren\">(</span><em>arr</em>, <em>sigma</em>, <em>mask=None</em>, <em>patch_radius=1</em>, <em>block_radius=5</em>, <em>rician=True</em>, <em>num_threads=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.nlmeans.nlmeans\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-local means for denoising 3D and 4D images</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D or 4D ndarray</span></dt>\n<dd><p class=\"first last\">The array to be denoised</p>\n</dd>\n<dt><strong>mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D ndarray</span></dt>\n<dd></dd>\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or 3D array</span></dt>\n<dd><p class=\"first last\">standard deviation of the noise estimated from the data</p>\n</dd>\n<dt><strong>patch_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt><strong>block_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt><strong>rician</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd><p class=\"first last\">If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n<dt><strong>num_threads</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">Number of threads. If None (default) then all available threads\nwill be used (all CPU cores).</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>denoised_arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd><p class=\"first last\">the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">References</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"r764c162eb15f-descoteaux08\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id6\">[Descoteaux08]</a></td><td>Descoteaux, Maxim and Wiest-Daessle`, Nicolas and Prima,\nSylvain and Barillot, Christian and Deriche, Rachid\nImpact of Rician Adapted Non-Local Means Filtering on\nHARDI, MICCAI 2008</td></tr>\n</tbody>\n</table>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlmeans-3d\">\n<h3>nlmeans_3d<a class=\"headerlink\" href=\"#nlmeans-3d\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.nlmeans.nlmeans_3d\">\n<code class=\"descclassname\">dipy.denoise.nlmeans.</code><code class=\"descname\">nlmeans_3d</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.nlmeans.nlmeans_3d\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-local means for denoising 3D images</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D ndarray</span></dt>\n<dd><p class=\"first last\">The array to be denoised</p>\n</dd>\n<dt><strong>mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D ndarray</span></dt>\n<dd></dd>\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or 3D array</span></dt>\n<dd><p class=\"first last\">standard deviation of the noise estimated from the data</p>\n</dd>\n<dt><strong>patch_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt><strong>block_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt><strong>rician</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd><p class=\"first last\">If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n<dt><strong>num_threads</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">Number of threads. If None (default) then all available threads\nwill be used.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>denoised_arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd><p class=\"first last\">the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"convolve\">\n<h3>convolve<a class=\"headerlink\" href=\"#convolve\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.noise_estimate.convolve\">\n<code class=\"descclassname\">dipy.denoise.noise_estimate.</code><code class=\"descname\">convolve</code><span class=\"sig-paren\">(</span><em>input</em>, <em>weights</em>, <em>output=None</em>, <em>mode='reflect'</em>, <em>cval=0.0</em>, <em>origin=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.convolve\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Multidimensional convolution.</p>\n<p>The array is convolved with the given kernel.</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>input</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd><p class=\"first last\">The input array.</p>\n</dd>\n<dt><strong>weights</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd><p class=\"first last\">Array of weights, same number of dimensions as input</p>\n</dd>\n<dt><strong>output</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array or dtype, optional</span></dt>\n<dd><p class=\"first last\">The array in which to place the output, or the dtype of the\nreturned array. By default an array of the same dtype as input\nwill be created.</p>\n</dd>\n<dt><strong>mode</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or sequence, optional</span></dt>\n<dd><p class=\"first\">The <cite>mode</cite> parameter determines how the input array is extended\nwhen the filter overlaps a border. By passing a sequence of modes\nwith length equal to the number of dimensions of the input array,\ndifferent modes can be specified along each axis. Default value is\n\u2018reflect\u2019. The valid values and their behavior is as follows:</p>\n<dl class=\"last docutils\">\n<dt>\u2018reflect\u2019 (<cite>d c b a | a b c d | d c b a</cite>)</dt>\n<dd><p class=\"first last\">The input is extended by reflecting about the edge of the last\npixel.</p>\n</dd>\n<dt>\u2018constant\u2019 (<cite>k k k k | a b c d | k k k k</cite>)</dt>\n<dd><p class=\"first last\">The input is extended by filling all values beyond the edge with\nthe same constant value, defined by the <cite>cval</cite> parameter.</p>\n</dd>\n<dt>\u2018nearest\u2019 (<cite>a a a a | a b c d | d d d d</cite>)</dt>\n<dd><p class=\"first last\">The input is extended by replicating the last pixel.</p>\n</dd>\n<dt>\u2018mirror\u2019 (<cite>d c b | a b c d | c b a</cite>)</dt>\n<dd><p class=\"first last\">The input is extended by reflecting about the center of the last\npixel.</p>\n</dd>\n<dt>\u2018wrap\u2019 (<cite>a b c d | a b c d | a b c d</cite>)</dt>\n<dd><p class=\"first last\">The input is extended by wrapping around to the opposite edge.</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>cval</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scalar, optional</span></dt>\n<dd><p class=\"first last\">Value to fill past edges of input if <cite>mode</cite> is \u2018constant\u2019. Default\nis 0.0</p>\n</dd>\n<dt><strong>origin</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int or sequence, optional</span></dt>\n<dd><p class=\"first last\">Controls the placement of the filter on the input array\u2019s pixels.\nA value of 0 (the default) centers the filter over the pixel, with\npositive values shifting the filter to the left, and negative ones\nto the right. By passing a sequence of origins with length equal to\nthe number of dimensions of the input array, different shifts can\nbe specified along each axis.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>result</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd><p class=\"first last\">The result of convolution of <cite>input</cite> with <cite>weights</cite>.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<div class=\"admonition seealso\">\n<p class=\"first admonition-title\">See also</p>\n<dl class=\"last docutils\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">correlate</span></code></dt>\n<dd>Correlate an image with a kernel.</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>Each value in result is <span class=\"math notranslate nohighlight\">\\(C_i = \\sum_j{I_{i+k-j} W_j}\\)</span>, where\nW is the <cite>weights</cite> kernel,\nj is the n-D spatial index over <span class=\"math notranslate nohighlight\">\\(W\\)</span>,\nI is the <cite>input</cite> and k is the coordinate of the center of\nW, specified by <cite>origin</cite> in the input parameters.</p>\n<p class=\"rubric\">Examples</p>\n<p>Perhaps the simplest case to understand is <code class=\"docutils literal notranslate\"><span class=\"pre\">mode='constant',</span> <span class=\"pre\">cval=0.0</span></code>,\nbecause in this case borders (i.e. where the <cite>weights</cite> kernel, centered\non any one value, extends beyond an edge of <cite>input</cite>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">ndimage</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;constant&#39;</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span>\n<span class=\"go\">array([[11, 10,  7,  4],</span>\n<span class=\"go\">       [10,  3, 11, 11],</span>\n<span class=\"go\">       [15, 12, 14,  7],</span>\n<span class=\"go\">       [12,  3,  7,  0]])</span>\n</pre></div>\n</div>\n<p>Setting <code class=\"docutils literal notranslate\"><span class=\"pre\">cval=1.0</span></code> is equivalent to padding the outer edge of <cite>input</cite>\nwith 1.0\u2019s (and then extracting only the original region of the result).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;constant&#39;</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n<span class=\"go\">array([[13, 11,  8,  7],</span>\n<span class=\"go\">       [11,  3, 11, 14],</span>\n<span class=\"go\">       [16, 12, 14, 10],</span>\n<span class=\"go\">       [15,  6, 10,  5]])</span>\n</pre></div>\n</div>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">mode='reflect'</span></code> (the default), outer values are reflected at the\nedge of <cite>input</cite> to fill in missing values.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;reflect&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">array([[5, 0, 0],</span>\n<span class=\"go\">       [3, 0, 0],</span>\n<span class=\"go\">       [1, 0, 0]])</span>\n</pre></div>\n</div>\n<p>This includes diagonally at the corners.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n<span class=\"go\">array([[4, 2, 0],</span>\n<span class=\"go\">       [3, 2, 0],</span>\n<span class=\"go\">       [1, 1, 0]])</span>\n</pre></div>\n</div>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">mode='nearest'</span></code>, the single nearest value in to an edge in\n<cite>input</cite> is repeated as many times as needed to match the overlapping\n<cite>weights</cite>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">array([[7, 0, 3],</span>\n<span class=\"go\">       [5, 0, 2],</span>\n<span class=\"go\">       [3, 0, 1]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"estimate-sigma\">\n<h3>estimate_sigma<a class=\"headerlink\" href=\"#estimate-sigma\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.noise_estimate.estimate_sigma\">\n<code class=\"descclassname\">dipy.denoise.noise_estimate.</code><code class=\"descname\">estimate_sigma</code><span class=\"sig-paren\">(</span><em>arr</em>, <em>disable_background_masking=False</em>, <em>N=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Standard deviation estimation from local patches</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D or 4D ndarray</span></dt>\n<dd><p class=\"first last\">The array to be estimated</p>\n</dd>\n<dt><strong>disable_background_masking</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, default False</span></dt>\n<dd><p class=\"first last\">If True, uses all voxels for the estimation, otherwise, only non-zeros\nvoxels are used. Useful if the background is masked by the scanner.</p>\n</dd>\n<dt><strong>N</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, default 0</span></dt>\n<dd><p class=\"first last\">Number of coils of the receiver array. Use N = 1 in case of a SENSE\nreconstruction (Philips scanners) or the number of coils for a GRAPPA\nreconstruction (Siemens and GE). Use 0 to disable the correction factor,\nas for example if the noise is Gaussian distributed. See [1] for more\ninformation.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd><p class=\"first last\">standard deviation of the noise, one estimation per volume.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"piesno\">\n<h3>piesno<a class=\"headerlink\" href=\"#piesno\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.noise_estimate.piesno\">\n<code class=\"descclassname\">dipy.denoise.noise_estimate.</code><code class=\"descname\">piesno</code><span class=\"sig-paren\">(</span><em>data</em>, <em>N</em>, <em>alpha=0.01</em>, <em>l=100</em>, <em>itermax=100</em>, <em>eps=1e-05</em>, <em>return_mask=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Probabilistic Identification and Estimation of Noise (PIESNO).</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>data</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd><p class=\"first last\">The magnitude signals to analyse. The last dimension must contain the\nsame realisation of the volume, such as dMRI or fMRI data.</p>\n</dd>\n<dt><strong>N</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">The number of phase array coils of the MRI scanner.\nIf your scanner does a SENSE reconstruction, ALWAYS use N=1, as the\nnoise profile is always Rician.\nIf your scanner does a GRAPPA reconstruction, set N as the number\nof phase array coils.</p>\n</dd>\n<dt><strong>alpha</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd><p class=\"first last\">Probabilistic estimation threshold for the gamma function.</p>\n</dd>\n<dt><strong>l</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">number of initial estimates for sigma to try.</p>\n</dd>\n<dt><strong>itermax</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">Maximum number of iterations to execute if convergence\nis not reached.</p>\n</dd>\n<dt><strong>eps</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd><p class=\"first last\">Tolerance for the convergence criterion. Convergence is\nreached if two subsequent estimates are smaller than eps.</p>\n</dd>\n<dt><strong>return_mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd><p class=\"first last\">If True, return a mask identyfing all the pure noise voxel\nthat were found.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd><p class=\"first last\">The estimated standard deviation of the gaussian noise.</p>\n</dd>\n<dt><strong>mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray (optional)</span></dt>\n<dd><p class=\"first last\">A boolean mask indicating the voxels identified as pure noise.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">References</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"rc7d3e0e673f9-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id7\">[1]</a></td><td>Koay CG, Ozarslan E and Pierpaoli C.</td></tr>\n</tbody>\n</table>\n<p>\u201cProbabilistic Identification and Estimation of Noise (PIESNO):\nA self-consistent approach and its applications in MRI.\u201d\nJournal of Magnetic Resonance 2009; 199: 94-103.</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"rc7d3e0e673f9-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id8\">[2]</a></td><td>Koay CG, Ozarslan E and Basser PJ.</td></tr>\n</tbody>\n</table>\n<p>\u201cA signal transformational framework for breaking the noise floor\nand its applications in MRI.\u201d\nJournal of Magnetic Resonance 2009; 197: 108-119.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlmeans-block\">\n<h3>nlmeans_block<a class=\"headerlink\" href=\"#nlmeans-block\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.non_local_means.nlmeans_block\">\n<code class=\"descclassname\">dipy.denoise.non_local_means.</code><code class=\"descname\">nlmeans_block</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.non_local_means.nlmeans_block\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-Local Means Denoising Using Blockwise Averaging</p>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>image</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D array of doubles</span></dt>\n<dd><p class=\"first last\">the input image, corrupted with rician noise</p>\n</dd>\n<dt><strong>mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D array of doubles</span></dt>\n<dd><p class=\"first last\">the input mask</p>\n</dd>\n<dt><strong>patch_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">similar patches in the non-local means are searched for locally,\ninside a cube of side 2*v+1 centered at each voxel of interest.</p>\n</dd>\n<dt><strong>block_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">the size of the block to be used (2*f+1)x(2*f+1)x(2*f+1) in the\nblockwise non-local means implementation (the Coupe\u2019s proposal).</p>\n</dd>\n<dt><strong>h</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">double</span></dt>\n<dd><p class=\"first last\">the estimated amount of rician noise in the input image: in P.\nCoupe et al. the rician noise was simulated as\nsqrt((f+x)^2 + (y)^2) where f is the pixel value and x and y are\nindependent realizations of a random variable with Normal\ndistribution, with mean=0 and standard deviation=h</p>\n</dd>\n<dt><strong>rician</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd><p class=\"first last\">If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>fima: 3D double array</strong></dt>\n<dd><p class=\"first last\">the denoised output which has the same shape as input image.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">References</p>\n<dl class=\"docutils\">\n<dt>[1] P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C. Barillot,</dt>\n<dd>\u201cAn Optimized Blockwise Non Local Means Denoising Filter for 3D Magnetic\nResonance Images\u201d\nIEEE Transactions on Medical Imaging, 27(4):425-441, 2008</dd>\n<dt>[2] Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.</dt>\n<dd>\u201cMultiresolution Non-Local Means Filter for 3D MR Image Denoising\u201d\nIET Image Processing, Institution of Engineering and Technology, 2011</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"non-local-means\">\n<h3>non_local_means<a class=\"headerlink\" href=\"#non-local-means\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.non_local_means.non_local_means\">\n<code class=\"descclassname\">dipy.denoise.non_local_means.</code><code class=\"descname\">non_local_means</code><span class=\"sig-paren\">(</span><em>arr</em>, <em>sigma</em>, <em>mask=None</em>, <em>patch_radius=1</em>, <em>block_radius=5</em>, <em>rician=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.non_local_means.non_local_means\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"docutils\">\n<dt>Non-local means for denoising 3D and 4D images, using</dt>\n<dd>blockwise averaging approach</dd>\n</dl>\n<table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><dl class=\"first docutils\">\n<dt><strong>arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D or 4D ndarray</span></dt>\n<dd><p class=\"first last\">The array to be denoised</p>\n</dd>\n<dt><strong>mask</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">3D ndarray</span></dt>\n<dd></dd>\n<dt><strong>sigma</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd><p class=\"first last\">standard deviation of the noise estimated from the data</p>\n</dd>\n<dt><strong>patch_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt><strong>block_radius</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd><p class=\"first last\">block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt><strong>rician</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd><p class=\"first last\">If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n</dl>\n</td>\n</tr>\n<tr class=\"field-even field\"><th class=\"field-name\">Returns:</th><td class=\"field-body\"><dl class=\"first last docutils\">\n<dt><strong>denoised_arr</strong> <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd><p class=\"first last\">the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"rubric\">References</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"rad5f4d89a56a-coupe08\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id9\">[Coupe08]</a></td><td>P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C.\nBarillot, An Optimized Blockwise Non Local Means Denoising\nFilter for 3D Magnetic Resonance Images, IEEE Transactions on\nMedical Imaging, 27(4):425-441, 2008</td></tr>\n</tbody>\n</table>\n<table class=\"docutils citation\" frame=\"void\" id=\"rad5f4d89a56a-coupe11\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id10\">[Coupe11]</a></td><td>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\nAdaptive Multiresolution Non-Local Means Filter for 3D MR Image\nDenoising IET Image Processing, Institution of Engineering and\nTechnology, 2011</td></tr>\n</tbody>\n</table>\n</dd></dl>\n\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["reference/dipy.direction", "<code class=\"docutils literal notranslate\"><span class=\"pre\">direction</span></code>", "N", "next"]], "sourcename": "reference/dipy.denoise.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\"><code class=\"docutils literal notranslate\"><span class=\"pre\">denoise</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.adaptive_soft_matching\">Module: <code class=\"docutils literal notranslate\"><span class=\"pre\">denoise.adaptive_soft_matching</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.localpca\">Module: <code class=\"docutils literal notranslate\"><span class=\"pre\">denoise.localpca</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.nlmeans\">Module: <code class=\"docutils literal notranslate\"><span class=\"pre\">denoise.nlmeans</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.noise_estimate\">Module: <code class=\"docutils literal notranslate\"><span class=\"pre\">denoise.noise_estimate</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.non_local_means\">Module: <code class=\"docutils literal notranslate\"><span class=\"pre\">denoise.non_local_means</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#bench\">bench</a></li>\n<li><a class=\"reference internal\" href=\"#test\">test</a></li>\n<li><a class=\"reference internal\" href=\"#adaptive-soft-matching\">adaptive_soft_matching</a></li>\n<li><a class=\"reference internal\" href=\"#eigh\">eigh</a></li>\n<li><a class=\"reference internal\" href=\"#localpca\">localpca</a></li>\n<li><a class=\"reference internal\" href=\"#nlmeans\">nlmeans</a></li>\n<li><a class=\"reference internal\" href=\"#nlmeans-3d\">nlmeans_3d</a></li>\n<li><a class=\"reference internal\" href=\"#convolve\">convolve</a></li>\n<li><a class=\"reference internal\" href=\"#estimate-sigma\">estimate_sigma</a></li>\n<li><a class=\"reference internal\" href=\"#piesno\">piesno</a></li>\n<li><a class=\"reference internal\" href=\"#nlmeans-block\">nlmeans_block</a></li>\n<li><a class=\"reference internal\" href=\"#non-local-means\">non_local_means</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "reference/dipy.denoise", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.11"}